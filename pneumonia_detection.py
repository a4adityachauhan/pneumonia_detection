# -*- coding: utf-8 -*-
"""Pneumonia_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ylRa_AuBfsIqY6c77VanTGB3-JUMQmM8
"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras import models
from sklearn.model_selection import train_test_split
import numpy as np
import pandas as pd
import cv2 
import zipfile
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import ModelCheckpoint

from google.colab import files
files.upload()
!pip install -q kaggle
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!kaggle datasets download -d paultimothymooney/chest-xray-pneumonia

z=zipfile.ZipFile('/content/chest-xray-pneumonia.zip').extractall()

import tensorflow as tf
from tensorflow.keras.layers import Input, Dense, Dropout, Conv2D, MaxPooling2D, Flatten, Dropout, BatchNormalization
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam


import numpy as np
!pip install SimpleITK
import SimpleITK as sitk
import cv2 as cv
import matplotlib.pyplot as plt
import os

from sklearn.model_selection import train_test_split
from mlxtend.plotting import plot_confusion_matrix
from sklearn.metrics import confusion_matrix

image_size = 224       #resize all images to 256*256

labels = ['NORMAL', 'PNEUMONIA'] 


def create_training_data(data_dir):              #creating the training data
    
    images = []
    
    for label in labels:
        dir = os.path.join(data_dir,label)
        class_num = labels.index(label)
        
        for image in os.listdir(dir):    #going through all the images in different folders and resizing them
            
            image_read = cv.imread(os.path.join(dir,image))
            image_resized = cv.resize(image_read,(image_size,image_size))
            imgg=cv2.cvtColor(image_resized, cv2.COLOR_BGR2RGB)
            images.append([imgg,class_num])
            
    return np.array(images)

train = create_training_data('/content/chest_xray/train')
test = create_training_data('/content/chest_xray/test')
val = create_training_data('/content/chest_xray/val')


X = []
y = []

for feature, label in train:
    X.append(feature)          #appending all images
    y.append(label)            #appending all labels

for feature, label in test:
    X.append(feature)
    y.append(label)

X=np.array(X)
y=np.array(y)
y = np.expand_dims(y, axis =1)
X.shape,y.shape

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state = 32)

X_train.shape

from keras import backend as K

def f1(y_true, y_pred):
    def recall(y_true, y_pred):
        """Recall metric.

        Only computes a batch-wise average of recall.

        Computes the recall, a metric for multi-label classification of
        how many relevant items are selected.
        """
        true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
        possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
        recall = true_positives / (possible_positives + K.epsilon())
        return recall

    def precision(y_true, y_pred):
        """Precision metric.

        Only computes a batch-wise average of precision.

        Computes the precision, a metric for multi-label classification of
        how many selected items are relevant.
        """
        true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
        predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
        precision = true_positives / (predicted_positives + K.epsilon())
        return precision
    precision = precision(y_true, y_pred)
    recall = recall(y_true, y_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))

print("Num GPUs Available: ", len(tf.config.experimental.list_physical_devices('GPU')))
print(tf.test.gpu_device_name())
tf.test.is_gpu_available()

batch_size = 16

train_gen = ImageDataGenerator(rotation_range=10,
                                   horizontal_flip = True,
                                   width_shift_range=0.1,
                                   height_shift_range=0.1,
                                   rescale=1.,
                                   zoom_range=0.2,
                                   fill_mode='nearest',
                                   cval=0)

train_generator = train_gen.flow(X_train,y_train,batch_size)
steps_per_epoch = X_train.shape[0]//batch_size

with tf.device("/device:GPU:0"):
    dense=keras.applications.DenseNet121(include_top=False,input_shape=(224,224,3),pooling='avg')
    out=Dense(1,activation='sigmoid')
    model=keras.models.Sequential([dense,out])
    # model.summary()
    checkpoint = ModelCheckpoint('Pneumonia1.h5', monitor='val_loss', verbose=1, save_best_only=True, mode='auto')
    model.compile(optimizer=tf.optimizers.Adam(lr = 0.0001), loss="binary_crossentropy", metrics=["accuracy",keras.metrics.AUC(),keras.metrics.Precision(),keras.metrics.Recall(),f1])
    r = model.fit(train_generator, validation_data=(X_test, y_test), steps_per_epoch = steps_per_epoch, epochs= 50,
                        callbacks = [checkpoint])

dependencies = {
    'f1': f1
}

mo=keras.models.load_model('/content/Pneumonia1.h5',custom_objects=dependencies)

def predict(path):
    img=cv.imread(path)
    image_resized = cv.resize(img,(224,224))
    imgg=cv2.cvtColor(image_resized, cv2.COLOR_BGR2RGB)
    dt=np.array(imgg)
    dt=dt.reshape((1,224,224,3))
    pred=mo.predict(dt)
    prediction=int(pred[0][0])
    if prediction==1:
        print('Pneumonia detected')
    if prediction==0:
        print('No Pneumonia found')

predict('/content/chest_xray/chest_xray/train/PNEUMONIA/person1000_bacteria_2931.jpeg')
predict('/content/chest_xray/chest_xray/train/NORMAL/IM-0117-0001.jpeg')

r.history.keys()

import matplotlib.pyplot as plt
plt.figure(1,figsize=(10,4))
plt.plot([i for i in  range(50)],r.history['accuracy'],label='accuracy')
plt.plot([i for i in  range(50)],r.history['val_auc'],label='val_accuracy')
plt.plot([i for i in  range(50)],r.history['f1'],label='f1')
plt.plot([i for i in  range(50)],r.history['val_f1'],label='val_f1')
plt.legend()

plt.figure(2,figsize=(10,4))
plt.plot([i for i in  range(50)],r.history['loss'],label='loss')
plt.plot([i for i in  range(50)],r.history['val_loss'],label='val_loss')
plt.legend()